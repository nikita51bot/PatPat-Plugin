import me.modmuss50.mpp.ReleaseType

plugins {
	id("java")
	id("xyz.jpenilla.run-paper") version "2.3.0"
	id("me.modmuss50.mod-publish-plugin") version "0.7.4"
}

group = prop("plugin_maven_group")
version = prop("plugin_version")

base {
	archivesName = prop("plugin_name")
}

repositories {
	mavenCentral()
	maven {
		name = "spigotmc-repo"
		url = "https://hub.spigotmc.org/nexus/content/repositories/snapshots/"
	}
	maven {
		name = "sonatype"
		url = "https://oss.sonatype.org/content/groups/public/"
	}
	maven {
		name = "papermc-repo"
		url = "https://repo.papermc.io/repository/maven-public/"
	}
}

configurations {
	extraLibs
}

dependencies {
	// Spigot API
	compileOnly("org.spigotmc:spigot-api:${prop("spigot-api")}")

	// Lombok
	compileOnly("org.projectlombok:lombok:${prop("lombok-version")}")
	annotationProcessor("org.projectlombok:lombok:${prop("lombok-version")}")

	// Jetbrains Annotations
	implementation("org.jetbrains:annotations:${prop("jetbrains-annotations")}")

	// Adventure-API
	implementation("net.kyori:adventure-platform-bukkit:4.3.4")
	extraLibs("net.kyori:adventure-platform-bukkit:4.3.4")

	testImplementation('ch.qos.logback:logback-classic:1.5.18')
	testImplementation(platform('org.junit:junit-bom:5.12.2'))
	testImplementation('org.junit.jupiter:junit-jupiter')
	testRuntimeOnly('org.junit.platform:junit-platform-launcher')
	testImplementation("org.mockbukkit.mockbukkit:mockbukkit-v1.21:4.0.0")
}

def mainJava = prop("java_version") as int
def testJava = 21

def mainJavaVersion = JavaVersion.toVersion(mainJava)
java {
	sourceCompatibility = mainJavaVersion
	targetCompatibility = mainJavaVersion
	if (JavaVersion.current() < mainJavaVersion) {
		toolchain.languageVersion = JavaLanguageVersion.of(mainJava)
	}
}

jar {
	duplicatesStrategy = DuplicatesStrategy.EXCLUDE
	from {
		configurations.extraLibs.collect {
			it.isDirectory() ? it : zipTree(it)
		}
	} {
		exclude 'META-INF/**'
	}
}

test {
	useJUnitPlatform()
}

tasks.named('compileTestJava') {
	javaCompiler = javaToolchains.compilerFor {
		languageVersion = JavaLanguageVersion.of(testJava)
	}
}

tasks.withType(JavaCompile).configureEach {
	options.encoding = 'UTF-8'
	if (it.name == 'compileJava') {
		options.release = mainJava
	} else if (it.name == 'compileTestJava') {
		options.release = testJava
	}
}

processResources {
	def props = [:]
	var buildTime = (int) (System.currentTimeMillis() / 10000) - 174611089
	var buildCode = String.format("%07x", buildTime & 0xFFFFFFF)
	props.put("version", "${prop("plugin_version")}+${buildCode}")

	props.each { key, value ->
		inputs.property key, value
	}

	filteringCharset 'UTF-8'
	filesMatching('plugin.yml') {
		expand(props)
	}
}

tasks.register('reBuild', Delete) {
	group("build")
	delete(project.rootProject.layout.buildDirectory.file("libs/${prop("plugin_name")}-${version}.jar"))
	finalizedBy("build")
}

tasks.register('copyPluginJar', Copy) {
	dependsOn jar
	onlyIf { project.hasProperty('outputDir') }

	from jar.archiveFile
	into file(project.findProperty('outputDir') ?: 'undefined')

	duplicatesStrategy = DuplicatesStrategy.INCLUDE

	doFirst {
		def targetDir = file(project.outputDir)
		if (!targetDir.exists()) {
			targetDir.mkdirs()
		}
		println "Copy JAR in: ${targetDir.absolutePath}"
	}
}
build.finalizedBy copyPluginJar

runServer {
	minecraftVersion(prop("minecraft_version").toString())
}

publishMods {
	def loaders = prop("loaders").toString().split(" ")
	def modrinthProjectId = prop("modrinth_id").toString()
	def embedsDepends = prop("embeds").toString().split(" ")
	def curseForgeProjectId = prop("curseforge_id").toString()
	def requiresDepends = prop("requires").toString().split(" ")
	def optionalDepends = prop("optional").toString().split(" ")
	def endSupportedVersion = prop("end_supported_version").toString()
	def incompatibleDepends = prop("incompatible").toString().split(" ")
	def startSupportedVersion = prop("start_supported_version").toString()
	def versionTypeProperty = prop("version_type").toString().replace("RELEASE", "STABLE")
	def maxJavaVersion = JavaVersion.toVersion(prop("max_java_version"))
	def isClient = Boolean.parseBoolean(prop("is_for_client)").toString())
	def isTesting = Boolean.parseBoolean(prop("test_publish)").toString())
	def isServer = Boolean.parseBoolean(prop("is_for_server)").toString())
	def versionName = "[${startSupportedVersion}-${endSupportedVersion}] ${prop("plugin_name")} v${prop("plugin_version")}"
	def bl = providers.environmentVariable("CURSEFORGE_API_KEY").getOrNull() == null
	def bl2 = providers.environmentVariable("MODRINTH_API_KEY").getOrNull() == null
	def bl3 = isTesting || bl || bl2

	println "[PublishMods] [INFO] Configuring '${versionName}' for publishing"

	displayName = versionName
	file = getVerifiedOrDefaultJar(prop("plugin_name"), prop("plugin_version"))
	changelog = getChangeLog()
	type = ReleaseType.of(versionTypeProperty)
	modLoaders.addAll(loaders)
	dryRun = bl3

	if (bl3) {
		println "[PublishMods] [WARNING] Test Mode is Enabled!"
	}

//	curseforge {
//		projectId = curseForgeProjectId
//		accessToken = providers.environmentVariable("CURSEFORGE_API_KEY")
//
//		for (i in javaVersion.ordinal()..<maxJavaVersion.ordinal() + 1) {
//			javaVersions.add(JavaVersion.values()[i])
//		}
//
//		clientRequired = isClient
//		serverRequired = isServer
//
//	if (startSupportedVersion != endSupportedVersion) {
//		minecraftVersionRange {
//			start = startSupportedVersion
//			end = endSupportedVersion
//		}
//	} else {
//		minecraftVersions.add(endSupportedVersion)
//	}
//
//		if (requiresDepends.first() != "none") {
//			requires(requiresDepends)
//		}
//		if (optionalDepends.first() != "none") {
//			optional(optionalDepends)
//		}
//		if (incompatibleDepends.first() != "none") {
//			incompatible(incompatibleDepends)
//		}
//		if (embedsDepends.first() != "none") {
//			embeds(embedsDepends)
//		}
//	}

	modrinth {
		displayName = "${prop("plugin_name")} v${prop("plugin_version")}"
		projectId = modrinthProjectId
		accessToken = providers.environmentVariable("MODRINTH_API_KEY")

		if (startSupportedVersion != endSupportedVersion) {
			minecraftVersionRange {
				start = startSupportedVersion
				end = endSupportedVersion
			}
		} else {
			minecraftVersions.add(endSupportedVersion)
		}

		if (requiresDepends.first() != "none") {
			requires(requiresDepends)
		}
		if (optionalDepends.first() != "none") {
			optional(optionalDepends)
		}
		if (incompatibleDepends.first() != "none") {
			incompatible(incompatibleDepends)
		}
		if (embedsDepends.first() != "none") {
			embeds(embedsDepends)
		}
	}
}

def getVerifiedOrDefaultJar(String pluginName, String pluginVersion) {
	def path = "libs/${pluginName}-${pluginVersion}.jar"
	def provider = project.rootProject.layout.buildDirectory.file(path)
	def regularFile = provider.orNull
	if (regularFile == null || !regularFile.getAsFile().exists()) {
		println "[PublishMods] Failed to find jar file at '${path}'! Using archive file!"
		return jar.archiveFile
	}
	return regularFile.getAsFile()
}

String getChangeLog() {
	def file = project.rootProject.file("publish/CHANGELOG.md")
	if (file.exists()) {
		def text = file.getText()
		if (!text.isBlank()) {
			return text
		}
	}
	return "No changelog specified."
}

String prop(String key) {
	return findProperty(key).toString()
}